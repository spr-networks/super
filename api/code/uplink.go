/*
Routines for managing the uplink interfaces, for outbound internet
*/
package main

import (
	"bytes"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"text/template"
)

/* Overall Uplinks configuration */

var gAPIUplinksConfigPath = TEST_PREFIX + "/configs/base/uplinks.json"

type UplinksConfig struct {
	LoadBalanceStrategy string
}

var Uplinksmtx sync.Mutex

func loadUplinksConfig() UplinksConfig {
	Uplinksmtx.Lock()
	defer Uplinksmtx.Unlock()

	data, err := os.ReadFile(gAPIUplinksConfigPath)
	config := UplinksConfig{}
	if err == nil {
		_ = json.Unmarshal(data, &config)
	}
	return config
}

func saveUplinksConfig(config UplinksConfig) error {
	Uplinksmtx.Lock()
	defer Uplinksmtx.Unlock()

	file, err := json.MarshalIndent(config, "", " ")
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(gAPIUplinksConfigPath, file, 0600)
	if err != nil {
		return err
	}
	return nil
}

/* WPA Supplicant Support */

var WpaConfigPath = TEST_PREFIX + "/configs/wifi_uplink/wpa.json"
var WPAmtx sync.Mutex

type WPANetwork struct {
	Disabled bool
	Password string
	SSID     string
	KeyMgmt  string
	Priority string `json:",omitempty"`
	BSSID    string `json:",omitempty"`
}

type WPAIface struct {
	Iface    string
	Enabled  bool
	Networks []WPANetwork
}

type WPASupplicantConfig struct {
	WPAs []WPAIface
}

func (n *WPANetwork) Validate() error {
	// Check for newlines in Password field
	if strings.Contains(n.Password, "\n") {
		return fmt.Errorf("Password field contains newline characters")
	}

	// Check for newlines in SSID field
	if strings.Contains(n.SSID, "\n") {
		return fmt.Errorf("SSID field contains newline characters")
	}

	if n.Priority != "" {
		_, err := strconv.Atoi(n.Priority)
		if err != nil {
			return fmt.Errorf("Priority field must contain numeric value")
		}
	}

	if n.BSSID != "" {
		// Check if BSSID field is a valid MAC address
		match, err := regexp.MatchString("^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$", n.BSSID)
		if err != nil || !match {
			return fmt.Errorf("BSSID field must be a valid MAC address")
		}
	}

	if n.KeyMgmt == "" {
		return fmt.Errorf("KeyMgmt field must be set (NONE, WPA-PSK, WPA-PSK-SHA256, or SAE)")
	}

	parts := strings.Split(n.KeyMgmt, " ")
	for _, part := range parts {
		if part == "NONE" {
			continue
		} else if part == "WPA-PSK" {
			continue
		} else if part == "WPA-PSK-SHA256" {
			continue
		} else if part == "SAE" {
			continue
		}
		return fmt.Errorf("KeyMgmt field has invalid value " + part)
	}

	return nil
}

func isWifiUplinkIfaceEnabled(Name string, interfaces []InterfaceConfig) bool {
	for _, iface := range interfaces {
		if iface.Name == Name {
			if iface.Type == "Uplink" && iface.Subtype == "wifi" {
				return iface.Enabled
			}
			break
		}
	}
	return false
}

func escapeWPAPassword(s string) string {
	s = strings.Replace(s, `"`, `\"`, -1)
	return `"` + s + `"`
}

func encodeSSID(ssid string) string {
	return hex.EncodeToString([]byte(ssid))
}

func writeWPAs(interfaces []InterfaceConfig, config WPASupplicantConfig) error {
	//assumes lock is held

	for _, wpa := range config.WPAs {

		//only keep an iface for the config if enabled
		//and the subtype matches
		if !wpa.Enabled {
			continue
		}

		funcMap := template.FuncMap{
			"encodeSSID":        encodeSSID,
			"escapeWPAPassword": escapeWPAPassword,
		}

		tmpl, err := template.New("wpa_supplicant.conf").Funcs(funcMap).Parse(`# Note this is an autogenerated file
ctrl_interface=DIR=/var/run/wpa_supplicant_` + wpa.Iface + `
{{range .Networks}}
{{if not .Disabled}}
network={
	ssid={{encodeSSID .SSID}}
	{{if ne .KeyMgmt "NONE"}}psk={{escapeWPAPassword .Password}}{{end}}
	{{if .Priority}}priority={{.Priority}}{{end}}
	{{if .BSSID}}bssid={{.BSSID}}{{end}}
	key_mgmt={{.KeyMgmt}}
}
{{end}}
{{end}}`)

		if err != nil {
			log.Println("Error parsing template:", err)
			return err
		}

		var result bytes.Buffer
		err = tmpl.Execute(&result, wpa)
		if err != nil {
			log.Println("Error executing template:", err)
			return err
		}
		fp := TEST_PREFIX + "/configs/wifi_uplink/wpa_" + wpa.Iface + ".conf"
		err = ioutil.WriteFile(fp, result.Bytes(), 0600)
		if err != nil {
			return err
		}
	}

	return nil
}

func loadWpaConfig() (WPASupplicantConfig, error) {
	WPAmtx.Lock()
	defer WPAmtx.Unlock()

	return loadWpaConfigLocked()
}
func loadWpaConfigLocked() (WPASupplicantConfig, error) {
	config := WPASupplicantConfig{}

	data, err := ioutil.ReadFile(WpaConfigPath)
	if err != nil {
		log.Println(err)
		return config, err
	} else {
		err = json.Unmarshal(data, &config)
		if err != nil {
			log.Println(err)
			return config, err
		}
	}
	return config, nil
}

func insertWpaConfigAndSave(interfaces []InterfaceConfig, new_wpa WPAIface) error {
	//assumes new_wpa is validated or empty and ignored
	// will clear out any wpas that are *not* set to uplink & wifi
	// in interfaces anymore
	// as well as inserting new_wpa
	WPAmtx.Lock()
	defer WPAmtx.Unlock()

	config := WPASupplicantConfig{}

	loaded, err := loadWpaConfigLocked()
	if err == nil {
		config = loaded
	}

	wpas := []WPAIface{}

	found := false
	for _, wpa := range config.WPAs {
		if wpa.Iface == new_wpa.Iface {
			wpas = append(wpas, new_wpa)
			found = true
		} else {
			//update the enabled status
			wpa.Enabled = isWifiUplinkIfaceEnabled(wpa.Iface, interfaces)
			wpas = append(wpas, wpa)
		}
	}

	if !found && new_wpa.Iface != "" {
		wpas = append(wpas, new_wpa)
	}

	config.WPAs = wpas

	file, _ := json.MarshalIndent(config, "", " ")
	err = ioutil.WriteFile(WpaConfigPath, file, 0600)
	if err != nil {
		log.Println(err)
		return err
	}

	return writeWPAs(interfaces, config)
}

func getWpaSupplicantConfig(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	config, err := loadWpaConfig()
	if err != nil {
		http.Error(w, "Failed to load wpa configuration", 400)
		return
	}
	json.NewEncoder(w).Encode(config)
}

func updateWpaSupplicantConfig(w http.ResponseWriter, r *http.Request) {
	wpa := WPAIface{}
	err := json.NewDecoder(r.Body).Decode(&wpa)
	if err != nil {
		http.Error(w, err.Error(), 400)
		return
	}

	enabled := false

	if !isValidIface(wpa.Iface) {
		log.Println("Invalid iface name", err)
		http.Error(w, "Invalid iface name", 400)
		return
	}

	for _, network := range wpa.Networks {

		//track whether at least one network is enabled.
		if !enabled {
			if network.Disabled == false {
				enabled = true
			}
		}

		if network.KeyMgmt == "" {
			network.KeyMgmt = "WPA-PSK WPA-PSK-SHA256"
		}
		err := network.Validate()
		if err != nil {
			log.Println("Validation error:", err)
			http.Error(w, "Failed to validate network "+err.Error(), 400)
			return
		}
	}

	//update the interface type
	interfaces, err := updateInterfaceType(wpa.Iface, "Uplink", "wifi", wpa.Enabled)
	if err != nil {
		log.Println(err)
		http.Error(w, err.Error(), 400)
		return
	}

	err = insertWpaConfigAndSave(interfaces, wpa)
	if err != nil {
		log.Println(err)
		http.Error(w, err.Error(), 400)
		return
	}

	uplink_plugin := "WIFIUPLINK"

	started := false
	if enabled {
		// at least one network is on, so ensure that the plugin is on
		started = enablePlugin(uplink_plugin)
	}

	//even if all were disabled, make sure to restart to reflect that.
	if !started {
		//restart the service if
		restartPlugin(uplink_plugin)
	}

}

/* PPP Support */

// /configs/ppp is mounted to /etc inside the container
var PPPConfigPath = TEST_PREFIX + "/configs/ppp/ppp.json"

var PPPmtx sync.Mutex

type PPPIface struct {
	Iface    string
	PPPIface string
	Enabled  bool
	Username string
	Secret   string
	VLAN     string `json,optional`
	MTU      string `json, optional`
}

type PPPConfig struct {
	PPPs []PPPIface
}

func (p *PPPIface) Validate() error {
	if !isValidIface(p.Iface) {
		return fmt.Errorf("Iface field empty")
	}

	if p.Username == "" {
		return fmt.Errorf("Username field empty")
	}

	if strings.Contains(p.Username, "\n") {
		return fmt.Errorf("Username field contains newline characters")
	}

	if strings.Contains(p.Secret, "\n") {
		return fmt.Errorf("Secret field contains newline characters")
	}

	if p.VLAN != "" {
		n, err := strconv.Atoi(p.VLAN)
		if err != nil || n < 0 {
			return fmt.Errorf("VLAN field must contain positive numeric value")
		}
		p.VLAN = fmt.Sprintf("%d", n)
	}

	if p.MTU != "" {
		v, err := strconv.Atoi(p.MTU)
		if err != nil || v < 0 {
			return fmt.Errorf("MTU field must contain numeric positive value")
		}
		p.MTU = fmt.Sprintf("%d", v)
	}

	return nil
}

func loadPPPConfig() (PPPConfig, error) {
	PPPmtx.Lock()
	defer PPPmtx.Unlock()

	return loadPPPConfigLocked()
}
func loadPPPConfigLocked() (PPPConfig, error) {
	config := PPPConfig{}

	data, err := ioutil.ReadFile(PPPConfigPath)
	if err != nil {
		log.Println(err)
		return config, err
	} else {
		err = json.Unmarshal(data, &config)
		if err != nil {
			log.Println(err)
			return config, err
		}
	}
	return config, nil

}

func writePPP(interfaces []InterfaceConfig, config PPPConfig) error {
	//assumes lock is held

	//chap secrets hosts all credentials
	tmpl, err := template.New("chap-secrets").Parse(`# Note this is an autogenerated file
    # Secrets for authentication using CHAP
    # client        server  secret                  IP addresses

    {{range .PPPs}}
      "{{.Username}}" * "{{.Secret}}"
    {{end}}
    `)

	if err != nil {
		log.Println("Error parsing template:", err)
		return err
	}

	var result bytes.Buffer
	err = tmpl.Execute(&result, config)
	if err != nil {
		log.Println("Error executing chap-secrets template:", err)
		return err
	}
	fp := TEST_PREFIX + "/configs/ppp/chap-secrets"
	err = ioutil.WriteFile(fp, result.Bytes(), 0600)
	if err != nil {
		return err
	}

	for _, ppp := range config.PPPs {

		tmpl, err := template.New("provider").Parse(`# Note this is an autogenerated file
# Minimalistic default options file for DSL/PPPoE connections
noipdefault
defaultroute
replacedefaultroute
persist
{{if .MTU}}mtu {{.MTU}}{{end}}
plugin rp-pppoe.so {{.Iface}}{{if .VLAN}}.{{.VLAN}}{{end}}
user "{{.Username}}"
`)

		if err != nil {
			log.Println("Error parsing template:", err)
			return err
		}

		var result bytes.Buffer
		err = tmpl.Execute(&result, ppp)
		if err != nil {
			log.Println("Error executing chap-secrets template:", err)
			return err
		}

		//make peers dir if it does not exist
		err = os.MkdirAll(TEST_PREFIX+"/configs/ppp/peers/", os.ModePerm)
		if err != nil {
			log.Println("Error creating directory:", err)
			return err
		}

		fp := TEST_PREFIX + "/configs/ppp/peers/provider_" + ppp.Iface
		err = ioutil.WriteFile(fp, result.Bytes(), 0600)
		if err != nil {
			return err
		}

	}

	return nil
}

func isPPPUplinkIfaceEnabled(Name string, interfaces []InterfaceConfig) bool {
	for _, iface := range interfaces {
		if iface.Name == Name {
			if iface.Type == "Uplink" && iface.Subtype == "pppup" {
				return iface.Enabled
			}
			break
		}
	}
	return false
}

func insertPPPConfigAndSave(interfaces []InterfaceConfig, new_ppp PPPIface) error {
	PPPmtx.Lock()
	defer PPPmtx.Unlock()

	config := PPPConfig{}

	loaded, err := loadPPPConfigLocked()
	if err == nil {
		config = loaded
	}

	ppps := []PPPIface{}

	found := false
	for i, ppp := range config.PPPs {
		if ppp.Iface == new_ppp.Iface {
			new_ppp.PPPIface = fmt.Sprintf("ppp%d", i)
			ppps = append(ppps, new_ppp)
			found = true
		} else {
			//update the enabled status
			ppp.Enabled = isPPPUplinkIfaceEnabled(ppp.Iface, interfaces)
			//update the index
			ppp.PPPIface = fmt.Sprintf("ppp%d", i)
			ppps = append(ppps, ppp)
		}
	}

	if !found && new_ppp.Iface != "" {
		new_ppp.PPPIface = fmt.Sprintf("ppp%d", len(ppps))
		ppps = append(ppps, new_ppp)
	}

	config.PPPs = ppps

	file, _ := json.MarshalIndent(config, "", " ")
	err = ioutil.WriteFile(PPPConfigPath, file, 0600)
	if err != nil {
		log.Println(err)
		return err
	}

	return writePPP(interfaces, config)
}

func getPPPConfig(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	config, err := loadPPPConfig()
	if err != nil {
		http.Error(w, "Failed to load ppp configuration", 400)
		return
	}
	json.NewEncoder(w).Encode(config)
}

func updatePPPConfig(w http.ResponseWriter, r *http.Request) {
	ppp := PPPIface{}
	err := json.NewDecoder(r.Body).Decode(&ppp)
	if err != nil {
		http.Error(w, err.Error(), 400)
		return
	}

	//ignore PPPIface from input. Will be set by updateInterface
	ppp.PPPIface = ""
	err = ppp.Validate()
	if err != nil {
		log.Println("Validation error:", err)
		http.Error(w, "Failed to validate ppp "+err.Error(), 400)
		return
	}

	//TBD additional work is needed here.
	// need to define a PPP0 ifname and store it.

	//update the interface type
	interfaces, err := updateInterfaceType(ppp.Iface, "Uplink", "pppup", ppp.Enabled)
	if err != nil {
		log.Println(err)
		http.Error(w, err.Error(), 400)
		return
	}

	err = insertPPPConfigAndSave(interfaces, ppp)
	if err != nil {
		log.Println(err)
		http.Error(w, err.Error(), 400)
		return
	}

	ppp_plugin := "PPP"
	started := enablePlugin(ppp_plugin)
	if !started {
		restartPlugin(ppp_plugin)
	}

}

/* Setting IP */
func updateLinkIPConfig(w http.ResponseWriter, r *http.Request) {
	iconfig := InterfaceConfig{}
	err := json.NewDecoder(r.Body).Decode(&iconfig)
	if err != nil {
		http.Error(w, err.Error(), 400)
		return
	}

	if iconfig.DisableDHCP == true {
		//validate router and ip when dhcp is disabled
		err = CIDRorIP(iconfig.IP)
		if err != nil {
			http.Error(w, err.Error(), 400)
			return
		}

		ip := net.ParseIP(iconfig.Router)
		if ip == nil {
			err = fmt.Errorf("invalid Router ip " + iconfig.Router)
			http.Error(w, err.Error(), 400)
			return
		}
	}

	if iconfig.VLAN != "" {
		http.Error(w, "VLAN Support not yet implemented for uplinks", 400)
		return

		/*
			n, err := strconv.Atoi(iconfig.VLAN)
			if err != nil || n < 0 {
				err = fmt.Errorf("VLAN field must contain positive numeric value")
				http.Error(w, err.Error(), 400)
				return
			}
			iconfig.VLAN = fmt.Sprintf("%d", n)
		*/
	}

	err = updateInterfaceIP(iconfig)
	if err != nil {
		log.Println(err)
		http.Error(w, err.Error(), 400)
		return
	}
}
